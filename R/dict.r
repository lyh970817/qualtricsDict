dict_generate <- function(newname = "easyVariableName",
                          survey_name,
                          split_by_block = FALSE,
                          survey_start = NULL,
                          survey_end = NULL,
                          json,
                          reference_dict = NULL,
                          dict_diff = NULL,
                          qid = FALSE,
                          api_key = NULL,
                          surveyID = NULL,
                          datacenter = NULL) {
  dict <- json %>% select(
    .data[[newname]], surveyBlock,
    itemLabel, recodeLevel, valueLabel
  )

  if (qid) {
    dict <- bind_cols(
      setNames(json["QuestionID"], paste("qid", survey_name, sep = "_")),
      dict
    )
  }

  attr(dict, "survey_name") <- survey_name

  if (!is.null(reference_dict)) {
    reference_dict[paste(
      "qid",
      attr(reference_dict, "survey_name"),
      sep = "_"
    )] <- NULL

    dict <- if (is.null(dict_diff)) {
      message("Consider using 'dict_compare' to track potential matching items")
      dict_merge(reference_dict, dict)
    } else {
      dict_merge(reference_dict, dict, dict_diff)
    }
    dict <- dict %>%
      filter(.data[[survey_name]]) %>%
      select(
        -contains(attr(reference_dict, "survey_name")),
        -.data[[survey_name]]
      )
  }

  if (split_by_block) {
    return(split(dict, dict$surveyBlock))
  } else {
    return(dict)
  }
}

dict_compare <- function(dict, reference_dict) {
  qtr <- reference_dict[["itemLabel"]]
  qt <- dict[["itemLabel"]]
  qt[qt %in% qtr] <- NA

  amatch_is <- amatch(qt, qtr, maxDist = 20)
  qt_is <- which(!is.na(amatch_is))
  qtr_is <- discard(amatch_is, is.na)

  return(
    tibble(
      name = dict[["easyVariableName"]][qt_is],
      itemLabel = qt[qt_is],
      name_reference = reference_dict[["easyVariableName"]][qtr_is],
      itemLabel_reference = qtr[qtr_is]
    ) %>%
      .[!duplicated(.), ] %>%
      na.omit()
  )
}

dict_merge <- function(dict,
                       reference_dict,
                       dict_diff = NULL,
                       match_name = NULL,
                       # match_recode = "reference",
                       upload = NULL) {
  if (attr(reference_dict, "survey_name") == attr(dict, "survey_name")) {
    stop("Dictionaries to be merged are from the same questionnaire.")
  }

  if (any(duplicated(dict_diff[["name"]]))) {
    stop("Non-unique mapping in dict_diff.")
  }

  qt <- dict[["itemLabel"]]
  qtr <- reference_dict[["itemLabel"]]

  match_is <- match(qt, qtr)
  qt_is <- which(!is.na(match_is))
  qtr_is <- discard(match_is, is.na)
  dict$easyVariableName[qt_is] <- reference_dict$easyVariableName[qtr_is]

  if (is.null(dict_diff)) {
    message("Consider using 'dict_compare' to track potential matching items")
  } else if (nrow(dict_diff) > 0) {
    dict <- dict %>%
      mutate(
        itemLabel = recode(
          itemLabel,
          !!!setNames(
            dict_diff[["itemLabel_reference"]],
            dict_diff[["itemLabel"]]
          )
        ),
        easyVariableName = recode(
          easyVariableName,
          !!!setNames(
            dict_diff[["name_reference"]],
            dict_diff[["name"]]
          )
        )
      )

    # dict[["itemLabel"]] <- qt %>%
    #   recode(!!!setNames(
    #     dict_diff[["itemLabel_reference"]],
    #     dict_diff[["itemLabel"]]
    #   ))
  }

  # If there is no survey indicator, add it
  if (!any(map_lgl(reference_dict, is.logical))) {
    reference_dict[attr(reference_dict, "survey_name")] <- TRUE
  }

  # Index the duplicated easyVariableNames in referencedict (in case it is
  # not generated by the package) and add a which column
  survey_name <- attr(dict, "survey_name")
  survey_name_ref <- attr(reference_dict, "survey_name")

  dict <- dict %>%
    group_by(easyVariableName, itemLabel, recodeLevel) %>%
    mutate(
      which = match_name_recode(
        seq_along(easyVariableName),
        match_name
      )
    ) %>%
    ungroup()

  dict %>% split(list(.$itemLabel, .$recodeLevel))

  reference_dict <- reference_dict %>%
    group_by(easyVariableName, itemLabel, recodeLevel) %>%
    mutate(
      easyVariableName = make.unique(easyVariableName),
      which = seq_along(easyVariableName)
    ) %>%
    ungroup()

  browser()
  # If there are no multiple instances in reference_dict,
  # there might be instances in dict that have not correspondence in
  # reference_dict

  # n_time_pts_ref <- reference_dict %>%
  #   split(list(.$itemLabel, .$recodeLevel)) %>%
  #   map_dbl(nrow)

  # n_time_pts <- dict %>%
  #   split(list(.$itemLabel, .$recodeLevel)) %>%
  #   map_dbl(nrow)

  # # We need to copy reference_dict for merge
  # if (all(n_time_pts <= 1)) {
  #   n_ins <- max(dict[["which"]])
  #   reference_dict <- reference_dict %>%
  #     slice(rep(1:n(), times = n_ins)) %>%
  #     group_by(itemLabel, recodeLevel) %>%
  #     mutate(
  #       which = seq(n_ins),
  #       survey_name_ref = c(TRUE, rep(NA, n_ins - 1))
  #     ) %>%
  #     select(-.data[[survey_name_ref]]) %>%
  #     rename(!!!setNames("survey_name_ref", survey_name_ref)) %>%
  #     ungroup()
  # }

  # Just use unite the first two easyVariableName columns!!!
  return(
    full_join(reference_dict, bind_cols(
      dict,
      setNames(tibble(TRUE), survey_name)
    ),
    by = c("easyVariableName", "itemLabel", "recodeLevel", "which"),
    suffix = c(
      paste0("_", survey_name_ref),
      paste0("_", survey_name)
    )
    ) %>%
      mutate(easyVariableName = paste(easyVariableName, which, sep = ".")) %>%
      # Discard the duplicated generated rows
      filter(!(which > 1 & is.na(.data[[survey_name]]))) %>%
      select(easyVariableName, everything(), -which)
  )
}


## Or do we just get a matrix and order the similarities?
